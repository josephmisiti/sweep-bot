from . import is_local as is_local
from ._function_utils import FunctionInfo as FunctionInfo
from ._resolver import Resolver as Resolver
from .config import config as config, logger as logger
from .exception import InvalidError as InvalidError, NotFoundError as NotFoundError, RemoteError as RemoteError
from .gpu import GPU_T as GPU_T, parse_gpu_config as parse_gpu_config
from .mount import _Mount
from .object import Handle as Handle, Provider as Provider
from .secret import _Secret
from .shared_volume import _SharedVolume
from _typeshed import Incomplete
from modal_proto import api_pb2
from pathlib import Path
from typing import Any, Callable, Collection, Dict, List, Optional, Union

class _ImageHandle(Handle): ...

class _ImageRegistryConfig:
    registry_type: Incomplete
    secret: Incomplete
    def __init__(self, registry_type: api_pb2.RegistryType.V = ..., secret: Optional[_Secret] = ...) -> None: ...
    async def resolve(self, resolver: Resolver) -> api_pb2.ImageRegistryConfig: ...

class _Image(Provider[_ImageHandle]):
    def extend(self, **kwargs) -> _Image: ...
    def copy(self, mount: _Mount, remote_path: Union[str, Path] = ...): ...
    def pip_install(self, *packages: Union[str, list[str]], find_links: Optional[str] = ..., index_url: Optional[str] = ..., extra_index_url: Optional[str] = ..., pre: bool = ...) -> _Image: ...
    def pip_install_private_repos(self, *repositories: str, git_user: str, secrets: Collection[_Secret] = ...) -> _Image: ...
    def pip_install_from_requirements(self, requirements_txt: str, find_links: Optional[str] = ...) -> _Image: ...
    def pip_install_from_pyproject(self, pyproject_toml: str, optional_dependencies: List[str] = ...): ...
    def poetry_install_from_file(self, poetry_pyproject_toml: str, poetry_lockfile: Optional[str] = ..., ignore_lockfile: bool = ..., old_installer: bool = ...): ...
    def dockerfile_commands(self, dockerfile_commands: Union[str, list[str]], context_files: dict[str, str] = ..., secrets: Collection[_Secret] = ..., gpu: GPU_T = ..., context_mount: Optional[_Mount] = ...): ...
    def run_commands(self, *commands: Union[str, list[str]], secrets: Collection[_Secret] = ..., gpu: GPU_T = ...): ...
    @staticmethod
    def conda(python_version: str = ...) -> _Image: ...
    def conda_install(self, *packages: Union[str, list[str]], channels: list[str] = ...) -> _Image: ...
    def conda_update_from_environment(self, environment_yml: str) -> _Image: ...
    @staticmethod
    def from_dockerhub(tag: str, setup_commands: list[str] = ..., **kwargs) -> _Image: ...
    @staticmethod
    def from_aws_ecr(tag: str, secret: Optional[_Secret] = ..., setup_commands: list[str] = ..., **kwargs) -> _Image: ...
    @staticmethod
    def from_dockerfile(path: Union[str, Path], context_mount: Optional[_Mount] = ...) -> _Image: ...
    @staticmethod
    def debian_slim(python_version: Optional[str] = ...) -> _Image: ...
    def apt_install(self, *packages: Union[str, list[str]]) -> _Image: ...
    def run_function(self, raw_f: Callable[[], Any], *, secret: Optional[_Secret] = ..., secrets: Collection[_Secret] = ..., gpu: GPU_T = ..., mounts: Collection[_Mount] = ..., shared_volumes: Dict[str, _SharedVolume] = ..., cpu: Optional[float] = ..., memory: Optional[int] = ..., timeout: Optional[int] = ..., cloud: Optional[str] = ...) -> _Image: ...
    def env(self, vars: dict[str, str]) -> _Image: ...

Image: Incomplete
AioImage: Incomplete
